#!/usr/bin/env ruby

require File.join(File.dirname(__FILE__), '..', 'config', 'environment')
require 'logger'
@logger = Logger.new(RAILS_ROOT + "/log/update_sources.log")

def parse_ffmpeg_info(raw_info, source)
  source.update_attribute(:ffmpeg_info, raw_info)
  {
    :duration    => parse_duration(raw_info),
    :bitrate     => parse_bitrate(raw_info),
    :video_codec => parse_video_codec(raw_info),
    :audio_codec => parse_audio_codec(raw_info),
    :resolution  => [*parse_resolution(raw_info)],
    :file_format => parse_file_format(raw_info),
  }
end

def parse_duration(raw_info)
  if raw_info =~ /Duration: ([^:]*):([^:]*):([^,]*)/
    hours   = $1.to_i
    minutes = $2.to_i
    seconds = $3.to_f
 
    duration = hours * 60 * 60 + minutes * 60 + seconds
	end
rescue
  nil
end

def parse_file_format(raw_info)
  $1 if raw_info =~ /Input \#0, ([^,]*)/
end

def parse_resolution(raw_info)
  [$1, $2].map(&:to_i) if raw_info =~ /([\d]{3,4})x([\d]{3,4})/
end

def parse_bitrate(raw_info)
  $1.to_i if raw_info =~ /bitrate: ([^ ]*)/
rescue
  nil
end

def parse_video_codec(raw_info)
  $1 if raw_info =~ /Video: ([^,]*)/
rescue
  nil
end

def parse_audio_codec(raw_info)
  $1 if raw_info =~ /Audio: ([^,]*)/
rescue
  nil
end

def tmp_file(source)
  "/tmp/source"
end

def screenshot_tmp_file(source)
  "#{tmp_file(source)}_screenshot.png"
end

def encoded_tmp_file(source)
  "#{tmp_file(source)}_encoded"
end

def remove_tmp_files
  @logger.info "Rm'ing\n"
  `rm /tmp/source*`
end

def download_file(source)
  @logger.info "Downloading"

  @curl_info = `curl -L '#{source.url.gsub("'", "")}' > #{tmp_file(source)}`

  source.update_attributes(:downloaded_at => Time.now, :curl_info => @curl_info)
end

def hash_file(source)
  @logger.info "Hashing"

  `sha1 #{tmp_file(source)} | cut -f1 -d" "`.strip
end

def get_video_info(source)
  @logger.info "FFmpeg'ing"

  info = parse_ffmpeg_info(`ffmpeg -i #{tmp_file(source)} 2>&1`, source)
  info[:file_size] = `ls -l #{tmp_file(source)} | awk '{print $5}'`.strip.to_i

  @logger.info "Got: #{info.inspect}"

  info
end

def screenshot_time(duration)
  time = duration / 3
  h = time / 60 * 60
  m = (time - h * 60 * 60) / 60
  s = time - h * 60 * 60 - m * 60

  [h,m,s].join(":")
end

def resized_size_of_video(info)
  # Use fancy mathematics to keep videos from being stretched into 320x240
  width  = 320
  height = width.to_f/info[:resolution][0] * info[:resolution][1]
  size   = [width, height].join("x")
end

def take_screen_shot(source, info)
  @logger.info "Screenshoting"

  size = resized_size_of_video(info)

  t = screenshot_time(info[:duration])
  `ffmpeg -y -i #{tmp_file(source)} -vframes 1 -s #{size} -ss #{t} -an -vcodec png -f rawvideo #{screenshot_tmp_file(source)}`

  if File.exists?(screenshot_tmp_file(source))
    source.attachment_for(:screenshot).assign(File.open(screenshot_tmp_file(source)))
    source.save!
  end
end

# ffmpeg -i diggnation--0184--clipshow2008--small.h264.mp4 -vcodec libx264 -acodec libfaac -b 256k -r 20 -ab 64k -ar 22050 -s 320x240 -t 30 a.h264.mp4
def encode_video(source, info)
  @logger.info "FLV'ing"
  length            = "00:05:00"
  video_bitrate     = 512.kilobytes
  audio_bitrate     = 96.kilobytes
  video_frame_rate  = 20
  audio_sample_rate = 44100

  size = resized_size_of_video(info)

  options = {
    :i  => tmp_file(source),  :f  => :flv,
    :ac => 1,                 :b  => video_bitrate,
    :r  => video_frame_rate,  :ab => audio_bitrate,
    :ar => audio_sample_rate, :t  => length,
    :s  => size
  }.map {|k,v| ["-#{k}", v] }.flatten.join(" ")

  `ffmpeg #{options} #{encoded_tmp_file(source)}`

  if File.exists?(encoded_tmp_file(source))
    source.attachment_for(:preview).assign(File.open(encoded_tmp_file(source)))
    source.save!
  end
end

def save_info(source, info)
  @logger.info "Updating"
  source.episode.update_attributes(
    :duration => info[:duration]
  )
  source.feed.update_attributes(
		:format   => info[:file_format] || info[:video_codec] || info[:audio_codec],
    :bitrate  => info[:bitrate]
  )
  source.update_attributes(
    :format   => info[:file_format] || info[:video_codec] || info[:audio_codec],
    :sha1hash => info[:sha1hash],
    :height   => info[:resolution][1],
    :width    => info[:resolution][0],
    :size     => info[:file_size]
  )
end

while true
  begin
    # Sleep 30 minutes until a source is found
    sleep 30.minutes.to_i until source = Source.find_by_sha1hash(nil, :order => "id DESC")

    download_file(source)

    # Get info about file
    info = get_video_info(source)

    info[:sha1hash] = hash_file(source)
    source.update_attribute(:hashed_at, Time.now)

    unless info[:video_codec].nil? || info[:duration].nil?
      # Get a screen shot
      take_screen_shot(source, info)

      # Create flv
      encode_video(source, info)
    end

    # Updates database with info taken from the video
    save_info(source, info)
  rescue
    @logger.fatal $!
    @logger.fatal $!.backtrace.join("\n")
  ensure
    remove_tmp_files
  end
end

